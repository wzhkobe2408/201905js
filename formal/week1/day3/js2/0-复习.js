/*
* js运行机制：
*   1. 作用域：供js代码从上到下执行的环境，存储基本数据类型的值；
*   作用域分类：
*     1. 全局作用域：浏览器打开一个页面时首先形成一个全局作用域（window）
*     2. 私有作用域（函数作用域）：函数执行时会创建一个私有作用域，这个私有作用域专门用来执行函数体中的代码；
*     3. 块级作用域：ES6新增的，把代码块（if/for代码块）都变成作用域，功能和私有作用域相似。
*
* js运行机制：
*   1. 在js代码执行之前，浏览器会先开辟一个全局作用域。然后进行全局作用域下的变量提升（变量提升就是在js代码执行前，对带var和function的进行提前的声明或者定义；其中带var的是只声明不定义，此时变量代表的是其默认值undefined，而带function是声明并且定义为函数自身）；
*   2. 变量提升结束后，js代码从上到下执行，开始给变量赋值，如果赋值的是基本数据类型，就把基本数据类型的值直接存储在作用域中，然后把变量和值关联起来。如果赋值的是一个引用数据类型值，浏览器会为其开辟一个堆内存空间，然后在堆内存中存储引用数据类型值（对象存键值对，数组存键值对+length、函数则以字符串的形式存储函数体中的代码）最后把堆内存地址赋值给变量（此时堆内存的地址存储在作用域中）；
*   3. 如果与到函数执行：
*     3.1 浏览器首先为函数执行创建一个私有作用域；
*     3.2 形参赋值，形参也是变量，是在这个阶段完成对形参的赋值
*     3.3 私有作用域中的变量提升
*     3.4 函数体中的代码从上到下执行；
* */

// 变量提升只发生在当前作用域中，如果函数不执行，函数里面的变量不会变量提升；

// 变量重复声明：
// 1. 多次声明同一个变量，浏览器不会多次声明，只会声明一次。多次赋值，变量代表最后一次被赋值的值；
var num;
var num = 1;
var num = 4;
var num = 5; // num代表的是5

function fe() {
  console.log(1);
}
function fe() { // fe代表的是 log(2) 的函数
  console.log(2);
}

// 3. 变量提升时，函数优先级高于普通变量；在变量名和函数名重名时，在变量被重新赋值前，fn一直代表函数。当被重新赋值后，代表被赋的值；

console.log(fn); // 函数
var fn = 123;
console.log(fn); // 123
function fn() {
  console.log(3);
}

console.log(foo); // foo 代表的还是 log(3)的函数，只要用var声明就是普通变量
var foo = function () {
  console.log(4);
};
function foo() {
  console.log(3);
}

// 变量提升的细节问题：
// 1. 等号右侧的不会进行变量提升，即使右侧是一个函数也不会提升；

// sum(1, 2); // 报错，因为不知道有sum这个变量
var usa = function sum(a, b) {
  return a + b;
};
sum(1, 3); // 在这里执行也会报错，因为浏览器在变量提升阶段记录自己作用域中有哪些变量，因为等号右侧不会发生变量提升，所以不会记录sum这个变量。当代码执行到这里时，变量提升已经结束了，所以此时浏览器还是不知道作用域中有sum这个变量，所以报错；

// 2. 在条件语句中的变量提升不会理会条件是否成立，都会变量提升；
// 在条件语句中，声明函数，如果条为false，不会给函数变量赋值；如过为true才会给变量赋值；（不推荐大家去条件中声明变量）
console.log(n); // undefined
if (false) {
  var n = 12;
  function bar() {
    console.log(123);
  }
} 
console.log(n); // undefined

// 3. return 右边的值不会进行变量提升，即使是一个函数也不行；
function seo() {
  // SEO Searching Engine Optimisation 搜索引擎优化
  // minus();// 报错
  return function minus() {
    console.log('TDK');
  }
}
seo();

// 4. return 下面代码虽然不会执行，但是仍然会进行变量提升
function tdk() {
  getAge(); // undefined,因为age在return下面，没办法赋值，所以只能是undefined
  return 'Title Description Keywords';
  var age = 10;
  function getAge() {
    console.log(age);
  }
}

// 带var和不带的区别：带var的会进行变量提升，不带var的不会进行变量提升；
var num = 12; // 在全局作用域中声明的变量会给window添加同名属性。

// in 运算符，检测一个对象是否包含一个属性

// 作用域链：变量的查找机制。当浏览器中访问一个变量时，会先在当前作用域中查找，如果找到就使用当前作用域中的变量。如果没找到，就向上级作用域查找，如果在上级作用域中找到，就使用，如果还没找到继续向上找，一直找到window，如果找到window还没有，有两种情况：如果是访问这个变量的值，报错；如果是赋值，就相当于给window添加了一个属性。

// 如何确定上级作用域？看函数定义时所在的作用域，定义时所在的作用域即函数的上级作用域；
function ok() {
  var num = 11;
  return function () {
    var num = 12;
    return function () {
      console.log(num);
    }
  }
}
ok();











