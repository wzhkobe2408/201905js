/*
* 正则：js内置类RegExp （RegExp 是一个函数数据类型的）专门用来处理字符串的规则；处理分为两种：
*   1. 正则匹配，判断某个字符串是否符合某个规则 RegExp.prototype.test()
*   2. 正则捕获，把符合规则的字符串获取到 RegExp.prototype.exec() String.prototype.match()
*
* 正则是由元字符和修饰符组成：/元字符/修饰符;
* 元字符：
*   1. 特殊元字符
*     \d 0-9任意一个数字
*     \D 除了0-9以外的任意一个字符
*     \w 数字、字母、_ 中的任意一个
*     \W 除了数字、字母、下划线以外的的任意一个
*     \s 匹配空白符（空格、\t 制表符 \n \r）
*     \b 匹配单词边界（字母与非字母连接处）
*     \n 匹配换行符
*     .  除\n 以外的任意字符
*     \ 转义符，把特殊的元字符转义成字符原义
*
*     ^ 读作caret 表示以某个元字符开头
*     $ 表示以某个元字符作为结尾
*     x|y 表示x或y中的一个
*     [xyz] x或y或z中的一个
*     [a-z] 匹配 a-z 中的一个小写字母
*     [A-Z] 匹配A-Z中任意一个大写字母
*     [0-9] 匹配中的任意一个数字 \d
*     [a-zA-Z0-9_] 等价于 \w
*     [^xyz] 除x、y、z以外的任意一个字符
*     () 正则分组
*     (?:) 取消分组捕获
*     (?=) 正向预查
*     (?!) 负向预查
*
*   2. 量词元字符
*     * 0次到多次
*     + 1次到多次
*     ? 0次到1次
*     {n} 只出现n次
*     {n,} 至少出现n次
*     {n,m} 出现n次到m次
*   3. 普通元字符：除了特殊元字符、量词元字符都是普通元字符
* 修饰符：
*   1. i ignorecase 忽略大小写匹配
*   2. m multiline 多行匹配
*   3. g global 全局匹配
*
*
*
* */
// 匹配字符串 \d
let reg = /\\d/; // 正则中元字符 \d 需要转义 \\d
// console.log(reg.test(`\\d`)); // 字符串中一个 \ 是转义符，如果在字符中使用这个 \ ，在字符串中也需要转义一次 \\d 转义之后表示 \d
// console.log('\\n'); // 把字符串中 \n 换行符通过 \ 转义成普通字符串 \n
// console.log('\\'); // 把 后面的 \ 转义成普通的斜杠，第一个斜杠作为转义符，不会输出，如果在字符串中写 \ 小心点。

let reg2 = /^$/g; // 匹配空字符串的方法（周文颖验证法）
let reg3 = /-/g; // - 表示一个普通元字符

// 正则匹配：用正则的test方法
let reg4 = /^1\d{7}(\d)\1{2}$/;
console.log(reg4.test('13412346777')); // true

// []的细节问题：
// 1. 有些特殊元字符在方括号中不在具有特殊意义，代表字符原义：[.] [+] [*] [?]
// 2. 中括号连续出现的多位数，不是代表一个多位数，而是代表多个一位数；[183] 不代表183，而是代表 1或者8或者3
// [23-68] 表示 2 或 3-6 或8，如果想表示23-68，就需要拆
// 23-29 2[3-9]
// 30-59 [3-5]\d
// 60-68 6[0-8]
// 拼接起来：/^(2[3-9]|[3-5]\d|6[0-8])$/ 加了^和$表示既是以这个内容开头，又要以这个结尾，就是只能是这个内容。
// 3. 方括号表示范围：前面的必须比后面小 ,不能写 z-a, Z-A , 9-0 ！！！

// 正则捕获：正则捕获使用正则exec方法、字符串match方法
let id = '0511120117'; // 前2位院系 2位专业 入学2位年份 2位班级 2位编号
let reg5 = /^(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})$/;
// console.log(reg5.test(id));

let data = {
  '05': '城建学院',
  '11': '土木工程',
  '12': '2012年',
  '01': '一班',
  '17': '马宾'
};
// 城建学院土木工程专业2012年一班马宾
// let str = data['05'] + data['11'] + '专业' + data['12'] + data['01'] + data['17'];
// console.log(str);

// 用正则捕获把数字从字符串中取出来
let execResult = reg5.exec(id);
console.log(execResult);

/*
* [
* "0511120117", // 这个大正则捕获到的内容
* "05", // 第一个分组捕获到的内容 院系
* "11", // 第二分组的内容 专业
* "12", // 第三个分组捕获内容 入学年份
* "01", // 第四个分组捕获的内容 班级
* "17", // 第五个分组捕获的内容 编号
* index: 0,
* input: "0511120117",
* groups: undefined
* ]
*
*
* */
let str2 = '';
for (let i = 1; i < execResult.length; i++) {
  let item = execResult[i];
  str2 += data[item];
  if (i === 2) {
    str2 += '专业'
  }
}
// console.log(str2);
// 通常我们使用 [索引]的方式从捕获结果中获取分组捕获的内容；
// RegExp 有几个属性，保存着正则分组捕获的到内容:
// $1-$9表示第1到第9个分组捕获到的内容(大于9的分组要自己通过索引的方式取)
// RegExp['$&'] 表示的大正则捕获到的内容
// console.log(RegExp.$1); 第一个分组
// console.log(RegExp.$2); 第二个分组
// console.log(RegExp.$3); 第三个分组
// console.log(RegExp.$4); 第四个分组
// console.log(RegExp.$5); 第五个分组
console.log(RegExp['$&']); // 大正则捕获到的内容

// 正则捕获的懒惰性：每次正则捕获时从索引为0的位置开始查找，捕获到第一个符合条件的就停止捕获，不管后面还有没有符合条件的。
// 解决懒惰性：在正则后加修饰符 g

// 正则捕获的贪婪性：一旦成功捕获，按照符合条件的最长的长度进行捕获；
// 解决贪婪性：量词元字符后面加 ?

// match 字符串方法：
// match 使用不带g的正则，捕获到的内容和exec捕获的内容一样
// match 使用带g的正则，会把所有匹配到的内容放到数组中，一次性捕获。

// lastIndex 下一次捕获或者匹配开始的位置，当正则找到末尾时，再捕获会返回null，但是下一次lastIndex会从0开始

// 邮箱验证正则：
var re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
