// 面向对象：
// 封装：单例（高级单例）、工厂模式、构造函数、原型模式
// 多态：（重写、重载）JS严格来说没有重载，模拟重载（根据不同参数做不同处理）
// 继承：子类继承父类；

function A() {
  // 通过 this.xxx = xxx; 方式添加的才是A类的实例私有的属性或者方法；
  this.text = 'A类的text';
}

A.prototype.say = function () { // 写在原型上的方法或者属性都是A类公有的属性和方法；
  console.log('hello world');
};

let a = new A(); // {text: '....', __proto__: ....}
console.log(a);
a.say(); // 对象.属性名 访问对象的某个属性时，首先在私有属性中查找，而私有属性中只有一个text属性，所以私有属性中没有say这个属性，接着去a所属类A的原型A.prototype 上查找公有属性和方法，在A的原型上有一个say方法；此时就找到了。
// 对象.属性名 在根据原型链查找的过程中，无论是找到私有的还是公有的，只要找到就算找到，找不到返回undefined；

function B() {}

let b = new B();
b.say(); // b的私有属性没有say方法，公有属性也没有say方法，所以 b.say 得到undefined，而undefined不能被执行，所以会报错；

// 现在我们需要让b能够调用到A类上的say这个方法；
// 我们能够让b调用say方法的前提是，say方法要么是b的私有属性，要么是b的公有属性；此时我们需要继承来实现，让B类继承A类；

// 让B类继承A类，我们称B类为子类，A类为父类（超类）；所谓的继承就是让子类的实例能够访问父类的属性和方法，继承就是把父类的私有属性或者公有属性变成子类的私有属性或者公有属性；